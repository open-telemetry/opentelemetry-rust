// This file is generated by rust-protobuf 2.16.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `opentelemetry/proto/trace/v1/trace.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_16_2;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ResourceSpans {
    // message fields
    pub resource: ::protobuf::SingularPtrField<super::resource::Resource>,
    pub instrumentation_library_spans: ::protobuf::RepeatedField<InstrumentationLibrarySpans>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResourceSpans {
    fn default() -> &'a ResourceSpans {
        <ResourceSpans as ::protobuf::Message>::default_instance()
    }
}

impl ResourceSpans {
    pub fn new() -> ResourceSpans {
        ::std::default::Default::default()
    }

    // .opentelemetry.proto.resource.v1.Resource resource = 1;


    pub fn get_resource(&self) -> &super::resource::Resource {
        self.resource.as_ref().unwrap_or_else(|| <super::resource::Resource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_resource(&mut self) {
        self.resource.clear();
    }

    pub fn has_resource(&self) -> bool {
        self.resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: super::resource::Resource) {
        self.resource = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut super::resource::Resource {
        if self.resource.is_none() {
            self.resource.set_default();
        }
        self.resource.as_mut().unwrap()
    }

    // Take field
    pub fn take_resource(&mut self) -> super::resource::Resource {
        self.resource.take().unwrap_or_else(|| super::resource::Resource::new())
    }

    // repeated .opentelemetry.proto.trace.v1.InstrumentationLibrarySpans instrumentation_library_spans = 2;


    pub fn get_instrumentation_library_spans(&self) -> &[InstrumentationLibrarySpans] {
        &self.instrumentation_library_spans
    }
    pub fn clear_instrumentation_library_spans(&mut self) {
        self.instrumentation_library_spans.clear();
    }

    // Param is passed by value, moved
    pub fn set_instrumentation_library_spans(&mut self, v: ::protobuf::RepeatedField<InstrumentationLibrarySpans>) {
        self.instrumentation_library_spans = v;
    }

    // Mutable pointer to the field.
    pub fn mut_instrumentation_library_spans(&mut self) -> &mut ::protobuf::RepeatedField<InstrumentationLibrarySpans> {
        &mut self.instrumentation_library_spans
    }

    // Take field
    pub fn take_instrumentation_library_spans(&mut self) -> ::protobuf::RepeatedField<InstrumentationLibrarySpans> {
        ::std::mem::replace(&mut self.instrumentation_library_spans, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ResourceSpans {
    fn is_initialized(&self) -> bool {
        for v in &self.resource {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.instrumentation_library_spans {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resource)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.instrumentation_library_spans)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.resource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.instrumentation_library_spans {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.resource.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.instrumentation_library_spans {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResourceSpans {
        ResourceSpans::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resource::Resource>>(
                "resource",
                |m: &ResourceSpans| { &m.resource },
                |m: &mut ResourceSpans| { &mut m.resource },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InstrumentationLibrarySpans>>(
                "instrumentation_library_spans",
                |m: &ResourceSpans| { &m.instrumentation_library_spans },
                |m: &mut ResourceSpans| { &mut m.instrumentation_library_spans },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResourceSpans>(
                "ResourceSpans",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResourceSpans {
        static instance: ::protobuf::rt::LazyV2<ResourceSpans> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResourceSpans::new)
    }
}

impl ::protobuf::Clear for ResourceSpans {
    fn clear(&mut self) {
        self.resource.clear();
        self.instrumentation_library_spans.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceSpans {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceSpans {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct InstrumentationLibrarySpans {
    // message fields
    pub instrumentation_library: ::protobuf::SingularPtrField<super::common::InstrumentationLibrary>,
    pub spans: ::protobuf::RepeatedField<Span>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstrumentationLibrarySpans {
    fn default() -> &'a InstrumentationLibrarySpans {
        <InstrumentationLibrarySpans as ::protobuf::Message>::default_instance()
    }
}

impl InstrumentationLibrarySpans {
    pub fn new() -> InstrumentationLibrarySpans {
        ::std::default::Default::default()
    }

    // .opentelemetry.proto.common.v1.InstrumentationLibrary instrumentation_library = 1;


    pub fn get_instrumentation_library(&self) -> &super::common::InstrumentationLibrary {
        self.instrumentation_library.as_ref().unwrap_or_else(|| <super::common::InstrumentationLibrary as ::protobuf::Message>::default_instance())
    }
    pub fn clear_instrumentation_library(&mut self) {
        self.instrumentation_library.clear();
    }

    pub fn has_instrumentation_library(&self) -> bool {
        self.instrumentation_library.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instrumentation_library(&mut self, v: super::common::InstrumentationLibrary) {
        self.instrumentation_library = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instrumentation_library(&mut self) -> &mut super::common::InstrumentationLibrary {
        if self.instrumentation_library.is_none() {
            self.instrumentation_library.set_default();
        }
        self.instrumentation_library.as_mut().unwrap()
    }

    // Take field
    pub fn take_instrumentation_library(&mut self) -> super::common::InstrumentationLibrary {
        self.instrumentation_library.take().unwrap_or_else(|| super::common::InstrumentationLibrary::new())
    }

    // repeated .opentelemetry.proto.trace.v1.Span spans = 2;


    pub fn get_spans(&self) -> &[Span] {
        &self.spans
    }
    pub fn clear_spans(&mut self) {
        self.spans.clear();
    }

    // Param is passed by value, moved
    pub fn set_spans(&mut self, v: ::protobuf::RepeatedField<Span>) {
        self.spans = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spans(&mut self) -> &mut ::protobuf::RepeatedField<Span> {
        &mut self.spans
    }

    // Take field
    pub fn take_spans(&mut self) -> ::protobuf::RepeatedField<Span> {
        ::std::mem::replace(&mut self.spans, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for InstrumentationLibrarySpans {
    fn is_initialized(&self) -> bool {
        for v in &self.instrumentation_library {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spans {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instrumentation_library)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.spans)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.instrumentation_library.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.spans {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.instrumentation_library.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.spans {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstrumentationLibrarySpans {
        InstrumentationLibrarySpans::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::InstrumentationLibrary>>(
                "instrumentation_library",
                |m: &InstrumentationLibrarySpans| { &m.instrumentation_library },
                |m: &mut InstrumentationLibrarySpans| { &mut m.instrumentation_library },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Span>>(
                "spans",
                |m: &InstrumentationLibrarySpans| { &m.spans },
                |m: &mut InstrumentationLibrarySpans| { &mut m.spans },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InstrumentationLibrarySpans>(
                "InstrumentationLibrarySpans",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InstrumentationLibrarySpans {
        static instance: ::protobuf::rt::LazyV2<InstrumentationLibrarySpans> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstrumentationLibrarySpans::new)
    }
}

impl ::protobuf::Clear for InstrumentationLibrarySpans {
    fn clear(&mut self) {
        self.instrumentation_library.clear();
        self.spans.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InstrumentationLibrarySpans {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstrumentationLibrarySpans {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Span {
    // message fields
    pub trace_id: ::std::vec::Vec<u8>,
    pub span_id: ::std::vec::Vec<u8>,
    pub trace_state: ::std::string::String,
    pub parent_span_id: ::std::vec::Vec<u8>,
    pub name: ::std::string::String,
    pub kind: Span_SpanKind,
    pub start_time_unix_nano: u64,
    pub end_time_unix_nano: u64,
    pub attributes: ::protobuf::RepeatedField<super::common::KeyValue>,
    pub dropped_attributes_count: u32,
    pub events: ::protobuf::RepeatedField<Span_Event>,
    pub dropped_events_count: u32,
    pub links: ::protobuf::RepeatedField<Span_Link>,
    pub dropped_links_count: u32,
    pub status: ::protobuf::SingularPtrField<Status>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Span {
    fn default() -> &'a Span {
        <Span as ::protobuf::Message>::default_instance()
    }
}

impl Span {
    pub fn new() -> Span {
        ::std::default::Default::default()
    }

    // bytes trace_id = 1;


    pub fn get_trace_id(&self) -> &[u8] {
        &self.trace_id
    }
    pub fn clear_trace_id(&mut self) {
        self.trace_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trace_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.trace_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.trace_id
    }

    // Take field
    pub fn take_trace_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.trace_id, ::std::vec::Vec::new())
    }

    // bytes span_id = 2;


    pub fn get_span_id(&self) -> &[u8] {
        &self.span_id
    }
    pub fn clear_span_id(&mut self) {
        self.span_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_span_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.span_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_span_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.span_id
    }

    // Take field
    pub fn take_span_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.span_id, ::std::vec::Vec::new())
    }

    // string trace_state = 3;


    pub fn get_trace_state(&self) -> &str {
        &self.trace_state
    }
    pub fn clear_trace_state(&mut self) {
        self.trace_state.clear();
    }

    // Param is passed by value, moved
    pub fn set_trace_state(&mut self, v: ::std::string::String) {
        self.trace_state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace_state(&mut self) -> &mut ::std::string::String {
        &mut self.trace_state
    }

    // Take field
    pub fn take_trace_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trace_state, ::std::string::String::new())
    }

    // bytes parent_span_id = 4;


    pub fn get_parent_span_id(&self) -> &[u8] {
        &self.parent_span_id
    }
    pub fn clear_parent_span_id(&mut self) {
        self.parent_span_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent_span_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.parent_span_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_span_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.parent_span_id
    }

    // Take field
    pub fn take_parent_span_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.parent_span_id, ::std::vec::Vec::new())
    }

    // string name = 5;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .opentelemetry.proto.trace.v1.Span.SpanKind kind = 6;


    pub fn get_kind(&self) -> Span_SpanKind {
        self.kind
    }
    pub fn clear_kind(&mut self) {
        self.kind = Span_SpanKind::SPAN_KIND_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: Span_SpanKind) {
        self.kind = v;
    }

    // fixed64 start_time_unix_nano = 7;


    pub fn get_start_time_unix_nano(&self) -> u64 {
        self.start_time_unix_nano
    }
    pub fn clear_start_time_unix_nano(&mut self) {
        self.start_time_unix_nano = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_time_unix_nano(&mut self, v: u64) {
        self.start_time_unix_nano = v;
    }

    // fixed64 end_time_unix_nano = 8;


    pub fn get_end_time_unix_nano(&self) -> u64 {
        self.end_time_unix_nano
    }
    pub fn clear_end_time_unix_nano(&mut self) {
        self.end_time_unix_nano = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_time_unix_nano(&mut self, v: u64) {
        self.end_time_unix_nano = v;
    }

    // repeated .opentelemetry.proto.common.v1.KeyValue attributes = 9;


    pub fn get_attributes(&self) -> &[super::common::KeyValue] {
        &self.attributes
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::protobuf::RepeatedField<super::common::KeyValue>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes(&mut self) -> &mut ::protobuf::RepeatedField<super::common::KeyValue> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::protobuf::RepeatedField<super::common::KeyValue> {
        ::std::mem::replace(&mut self.attributes, ::protobuf::RepeatedField::new())
    }

    // uint32 dropped_attributes_count = 10;


    pub fn get_dropped_attributes_count(&self) -> u32 {
        self.dropped_attributes_count
    }
    pub fn clear_dropped_attributes_count(&mut self) {
        self.dropped_attributes_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_dropped_attributes_count(&mut self, v: u32) {
        self.dropped_attributes_count = v;
    }

    // repeated .opentelemetry.proto.trace.v1.Span.Event events = 11;


    pub fn get_events(&self) -> &[Span_Event] {
        &self.events
    }
    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::protobuf::RepeatedField<Span_Event>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events(&mut self) -> &mut ::protobuf::RepeatedField<Span_Event> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::protobuf::RepeatedField<Span_Event> {
        ::std::mem::replace(&mut self.events, ::protobuf::RepeatedField::new())
    }

    // uint32 dropped_events_count = 12;


    pub fn get_dropped_events_count(&self) -> u32 {
        self.dropped_events_count
    }
    pub fn clear_dropped_events_count(&mut self) {
        self.dropped_events_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_dropped_events_count(&mut self, v: u32) {
        self.dropped_events_count = v;
    }

    // repeated .opentelemetry.proto.trace.v1.Span.Link links = 13;


    pub fn get_links(&self) -> &[Span_Link] {
        &self.links
    }
    pub fn clear_links(&mut self) {
        self.links.clear();
    }

    // Param is passed by value, moved
    pub fn set_links(&mut self, v: ::protobuf::RepeatedField<Span_Link>) {
        self.links = v;
    }

    // Mutable pointer to the field.
    pub fn mut_links(&mut self) -> &mut ::protobuf::RepeatedField<Span_Link> {
        &mut self.links
    }

    // Take field
    pub fn take_links(&mut self) -> ::protobuf::RepeatedField<Span_Link> {
        ::std::mem::replace(&mut self.links, ::protobuf::RepeatedField::new())
    }

    // uint32 dropped_links_count = 14;


    pub fn get_dropped_links_count(&self) -> u32 {
        self.dropped_links_count
    }
    pub fn clear_dropped_links_count(&mut self) {
        self.dropped_links_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_dropped_links_count(&mut self, v: u32) {
        self.dropped_links_count = v;
    }

    // .opentelemetry.proto.trace.v1.Status status = 15;


    pub fn get_status(&self) -> &Status {
        self.status.as_ref().unwrap_or_else(|| <Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> Status {
        self.status.take().unwrap_or_else(|| Status::new())
    }
}

impl ::protobuf::Message for Span {
    fn is_initialized(&self) -> bool {
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.events {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.links {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.trace_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.span_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trace_state)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.parent_span_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.kind, 6, &mut self.unknown_fields)?
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.start_time_unix_nano = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.end_time_unix_nano = tmp;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attributes)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dropped_attributes_count = tmp;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.events)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dropped_events_count = tmp;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.links)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dropped_links_count = tmp;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.trace_id);
        }
        if !self.span_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.span_id);
        }
        if !self.trace_state.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.trace_state);
        }
        if !self.parent_span_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.parent_span_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.name);
        }
        if self.kind != Span_SpanKind::SPAN_KIND_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(6, self.kind);
        }
        if self.start_time_unix_nano != 0 {
            my_size += 9;
        }
        if self.end_time_unix_nano != 0 {
            my_size += 9;
        }
        for value in &self.attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.dropped_attributes_count != 0 {
            my_size += ::protobuf::rt::value_size(10, self.dropped_attributes_count, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.dropped_events_count != 0 {
            my_size += ::protobuf::rt::value_size(12, self.dropped_events_count, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.links {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.dropped_links_count != 0 {
            my_size += ::protobuf::rt::value_size(14, self.dropped_links_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.trace_id.is_empty() {
            os.write_bytes(1, &self.trace_id)?;
        }
        if !self.span_id.is_empty() {
            os.write_bytes(2, &self.span_id)?;
        }
        if !self.trace_state.is_empty() {
            os.write_string(3, &self.trace_state)?;
        }
        if !self.parent_span_id.is_empty() {
            os.write_bytes(4, &self.parent_span_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(5, &self.name)?;
        }
        if self.kind != Span_SpanKind::SPAN_KIND_UNSPECIFIED {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.kind))?;
        }
        if self.start_time_unix_nano != 0 {
            os.write_fixed64(7, self.start_time_unix_nano)?;
        }
        if self.end_time_unix_nano != 0 {
            os.write_fixed64(8, self.end_time_unix_nano)?;
        }
        for v in &self.attributes {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.dropped_attributes_count != 0 {
            os.write_uint32(10, self.dropped_attributes_count)?;
        }
        for v in &self.events {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.dropped_events_count != 0 {
            os.write_uint32(12, self.dropped_events_count)?;
        }
        for v in &self.links {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.dropped_links_count != 0 {
            os.write_uint32(14, self.dropped_links_count)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Span {
        Span::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "trace_id",
                |m: &Span| { &m.trace_id },
                |m: &mut Span| { &mut m.trace_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "span_id",
                |m: &Span| { &m.span_id },
                |m: &mut Span| { &mut m.span_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "trace_state",
                |m: &Span| { &m.trace_state },
                |m: &mut Span| { &mut m.trace_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "parent_span_id",
                |m: &Span| { &m.parent_span_id },
                |m: &mut Span| { &mut m.parent_span_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Span| { &m.name },
                |m: &mut Span| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Span_SpanKind>>(
                "kind",
                |m: &Span| { &m.kind },
                |m: &mut Span| { &mut m.kind },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "start_time_unix_nano",
                |m: &Span| { &m.start_time_unix_nano },
                |m: &mut Span| { &mut m.start_time_unix_nano },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "end_time_unix_nano",
                |m: &Span| { &m.end_time_unix_nano },
                |m: &mut Span| { &mut m.end_time_unix_nano },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::KeyValue>>(
                "attributes",
                |m: &Span| { &m.attributes },
                |m: &mut Span| { &mut m.attributes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dropped_attributes_count",
                |m: &Span| { &m.dropped_attributes_count },
                |m: &mut Span| { &mut m.dropped_attributes_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Span_Event>>(
                "events",
                |m: &Span| { &m.events },
                |m: &mut Span| { &mut m.events },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dropped_events_count",
                |m: &Span| { &m.dropped_events_count },
                |m: &mut Span| { &mut m.dropped_events_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Span_Link>>(
                "links",
                |m: &Span| { &m.links },
                |m: &mut Span| { &mut m.links },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dropped_links_count",
                |m: &Span| { &m.dropped_links_count },
                |m: &mut Span| { &mut m.dropped_links_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Status>>(
                "status",
                |m: &Span| { &m.status },
                |m: &mut Span| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Span>(
                "Span",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Span {
        static instance: ::protobuf::rt::LazyV2<Span> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Span::new)
    }
}

impl ::protobuf::Clear for Span {
    fn clear(&mut self) {
        self.trace_id.clear();
        self.span_id.clear();
        self.trace_state.clear();
        self.parent_span_id.clear();
        self.name.clear();
        self.kind = Span_SpanKind::SPAN_KIND_UNSPECIFIED;
        self.start_time_unix_nano = 0;
        self.end_time_unix_nano = 0;
        self.attributes.clear();
        self.dropped_attributes_count = 0;
        self.events.clear();
        self.dropped_events_count = 0;
        self.links.clear();
        self.dropped_links_count = 0;
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Span {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Span {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Span_Event {
    // message fields
    pub time_unix_nano: u64,
    pub name: ::std::string::String,
    pub attributes: ::protobuf::RepeatedField<super::common::KeyValue>,
    pub dropped_attributes_count: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Span_Event {
    fn default() -> &'a Span_Event {
        <Span_Event as ::protobuf::Message>::default_instance()
    }
}

impl Span_Event {
    pub fn new() -> Span_Event {
        ::std::default::Default::default()
    }

    // fixed64 time_unix_nano = 1;


    pub fn get_time_unix_nano(&self) -> u64 {
        self.time_unix_nano
    }
    pub fn clear_time_unix_nano(&mut self) {
        self.time_unix_nano = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_unix_nano(&mut self, v: u64) {
        self.time_unix_nano = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .opentelemetry.proto.common.v1.KeyValue attributes = 3;


    pub fn get_attributes(&self) -> &[super::common::KeyValue] {
        &self.attributes
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::protobuf::RepeatedField<super::common::KeyValue>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes(&mut self) -> &mut ::protobuf::RepeatedField<super::common::KeyValue> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::protobuf::RepeatedField<super::common::KeyValue> {
        ::std::mem::replace(&mut self.attributes, ::protobuf::RepeatedField::new())
    }

    // uint32 dropped_attributes_count = 4;


    pub fn get_dropped_attributes_count(&self) -> u32 {
        self.dropped_attributes_count
    }
    pub fn clear_dropped_attributes_count(&mut self) {
        self.dropped_attributes_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_dropped_attributes_count(&mut self, v: u32) {
        self.dropped_attributes_count = v;
    }
}

impl ::protobuf::Message for Span_Event {
    fn is_initialized(&self) -> bool {
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.time_unix_nano = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attributes)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dropped_attributes_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.time_unix_nano != 0 {
            my_size += 9;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.dropped_attributes_count != 0 {
            my_size += ::protobuf::rt::value_size(4, self.dropped_attributes_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.time_unix_nano != 0 {
            os.write_fixed64(1, self.time_unix_nano)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.attributes {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.dropped_attributes_count != 0 {
            os.write_uint32(4, self.dropped_attributes_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Span_Event {
        Span_Event::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "time_unix_nano",
                |m: &Span_Event| { &m.time_unix_nano },
                |m: &mut Span_Event| { &mut m.time_unix_nano },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Span_Event| { &m.name },
                |m: &mut Span_Event| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::KeyValue>>(
                "attributes",
                |m: &Span_Event| { &m.attributes },
                |m: &mut Span_Event| { &mut m.attributes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dropped_attributes_count",
                |m: &Span_Event| { &m.dropped_attributes_count },
                |m: &mut Span_Event| { &mut m.dropped_attributes_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Span_Event>(
                "Span.Event",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Span_Event {
        static instance: ::protobuf::rt::LazyV2<Span_Event> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Span_Event::new)
    }
}

impl ::protobuf::Clear for Span_Event {
    fn clear(&mut self) {
        self.time_unix_nano = 0;
        self.name.clear();
        self.attributes.clear();
        self.dropped_attributes_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Span_Event {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Span_Event {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Span_Link {
    // message fields
    pub trace_id: ::std::vec::Vec<u8>,
    pub span_id: ::std::vec::Vec<u8>,
    pub trace_state: ::std::string::String,
    pub attributes: ::protobuf::RepeatedField<super::common::KeyValue>,
    pub dropped_attributes_count: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Span_Link {
    fn default() -> &'a Span_Link {
        <Span_Link as ::protobuf::Message>::default_instance()
    }
}

impl Span_Link {
    pub fn new() -> Span_Link {
        ::std::default::Default::default()
    }

    // bytes trace_id = 1;


    pub fn get_trace_id(&self) -> &[u8] {
        &self.trace_id
    }
    pub fn clear_trace_id(&mut self) {
        self.trace_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trace_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.trace_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.trace_id
    }

    // Take field
    pub fn take_trace_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.trace_id, ::std::vec::Vec::new())
    }

    // bytes span_id = 2;


    pub fn get_span_id(&self) -> &[u8] {
        &self.span_id
    }
    pub fn clear_span_id(&mut self) {
        self.span_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_span_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.span_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_span_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.span_id
    }

    // Take field
    pub fn take_span_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.span_id, ::std::vec::Vec::new())
    }

    // string trace_state = 3;


    pub fn get_trace_state(&self) -> &str {
        &self.trace_state
    }
    pub fn clear_trace_state(&mut self) {
        self.trace_state.clear();
    }

    // Param is passed by value, moved
    pub fn set_trace_state(&mut self, v: ::std::string::String) {
        self.trace_state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace_state(&mut self) -> &mut ::std::string::String {
        &mut self.trace_state
    }

    // Take field
    pub fn take_trace_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trace_state, ::std::string::String::new())
    }

    // repeated .opentelemetry.proto.common.v1.KeyValue attributes = 4;


    pub fn get_attributes(&self) -> &[super::common::KeyValue] {
        &self.attributes
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::protobuf::RepeatedField<super::common::KeyValue>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes(&mut self) -> &mut ::protobuf::RepeatedField<super::common::KeyValue> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::protobuf::RepeatedField<super::common::KeyValue> {
        ::std::mem::replace(&mut self.attributes, ::protobuf::RepeatedField::new())
    }

    // uint32 dropped_attributes_count = 5;


    pub fn get_dropped_attributes_count(&self) -> u32 {
        self.dropped_attributes_count
    }
    pub fn clear_dropped_attributes_count(&mut self) {
        self.dropped_attributes_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_dropped_attributes_count(&mut self, v: u32) {
        self.dropped_attributes_count = v;
    }
}

impl ::protobuf::Message for Span_Link {
    fn is_initialized(&self) -> bool {
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.trace_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.span_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trace_state)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attributes)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dropped_attributes_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.trace_id);
        }
        if !self.span_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.span_id);
        }
        if !self.trace_state.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.trace_state);
        }
        for value in &self.attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.dropped_attributes_count != 0 {
            my_size += ::protobuf::rt::value_size(5, self.dropped_attributes_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.trace_id.is_empty() {
            os.write_bytes(1, &self.trace_id)?;
        }
        if !self.span_id.is_empty() {
            os.write_bytes(2, &self.span_id)?;
        }
        if !self.trace_state.is_empty() {
            os.write_string(3, &self.trace_state)?;
        }
        for v in &self.attributes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.dropped_attributes_count != 0 {
            os.write_uint32(5, self.dropped_attributes_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Span_Link {
        Span_Link::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "trace_id",
                |m: &Span_Link| { &m.trace_id },
                |m: &mut Span_Link| { &mut m.trace_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "span_id",
                |m: &Span_Link| { &m.span_id },
                |m: &mut Span_Link| { &mut m.span_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "trace_state",
                |m: &Span_Link| { &m.trace_state },
                |m: &mut Span_Link| { &mut m.trace_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::KeyValue>>(
                "attributes",
                |m: &Span_Link| { &m.attributes },
                |m: &mut Span_Link| { &mut m.attributes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dropped_attributes_count",
                |m: &Span_Link| { &m.dropped_attributes_count },
                |m: &mut Span_Link| { &mut m.dropped_attributes_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Span_Link>(
                "Span.Link",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Span_Link {
        static instance: ::protobuf::rt::LazyV2<Span_Link> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Span_Link::new)
    }
}

impl ::protobuf::Clear for Span_Link {
    fn clear(&mut self) {
        self.trace_id.clear();
        self.span_id.clear();
        self.trace_state.clear();
        self.attributes.clear();
        self.dropped_attributes_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Span_Link {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Span_Link {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum Span_SpanKind {
    SPAN_KIND_UNSPECIFIED = 0,
    INTERNAL = 1,
    SERVER = 2,
    CLIENT = 3,
    PRODUCER = 4,
    CONSUMER = 5,
}

impl ::protobuf::ProtobufEnum for Span_SpanKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Span_SpanKind> {
        match value {
            0 => ::std::option::Option::Some(Span_SpanKind::SPAN_KIND_UNSPECIFIED),
            1 => ::std::option::Option::Some(Span_SpanKind::INTERNAL),
            2 => ::std::option::Option::Some(Span_SpanKind::SERVER),
            3 => ::std::option::Option::Some(Span_SpanKind::CLIENT),
            4 => ::std::option::Option::Some(Span_SpanKind::PRODUCER),
            5 => ::std::option::Option::Some(Span_SpanKind::CONSUMER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Span_SpanKind] = &[
            Span_SpanKind::SPAN_KIND_UNSPECIFIED,
            Span_SpanKind::INTERNAL,
            Span_SpanKind::SERVER,
            Span_SpanKind::CLIENT,
            Span_SpanKind::PRODUCER,
            Span_SpanKind::CONSUMER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Span_SpanKind>("Span.SpanKind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Span_SpanKind {
}

impl ::std::default::Default for Span_SpanKind {
    fn default() -> Self {
        Span_SpanKind::SPAN_KIND_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Span_SpanKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Status {
    // message fields
    pub code: Status_StatusCode,
    pub message: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Status {
    fn default() -> &'a Status {
        <Status as ::protobuf::Message>::default_instance()
    }
}

impl Status {
    pub fn new() -> Status {
        ::std::default::Default::default()
    }

    // .opentelemetry.proto.trace.v1.Status.StatusCode code = 1;


    pub fn get_code(&self) -> Status_StatusCode {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = Status_StatusCode::Ok;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: Status_StatusCode) {
        self.code = v;
    }

    // string message = 2;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Status {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.code, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != Status_StatusCode::Ok {
            my_size += ::protobuf::rt::enum_size(1, self.code);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.code != Status_StatusCode::Ok {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.code))?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Status {
        Status::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Status_StatusCode>>(
                "code",
                |m: &Status| { &m.code },
                |m: &mut Status| { &mut m.code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &Status| { &m.message },
                |m: &mut Status| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Status>(
                "Status",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Status {
        static instance: ::protobuf::rt::LazyV2<Status> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Status::new)
    }
}

impl ::protobuf::Clear for Status {
    fn clear(&mut self) {
        self.code = Status_StatusCode::Ok;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Status {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Status {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum Status_StatusCode {
    Ok = 0,
    Cancelled = 1,
    UnknownError = 2,
    InvalidArgument = 3,
    DeadlineExceeded = 4,
    NotFound = 5,
    AlreadyExists = 6,
    PermissionDenied = 7,
    ResourceExhausted = 8,
    FailedPrecondition = 9,
    Aborted = 10,
    OutOfRange = 11,
    Unimplemented = 12,
    InternalError = 13,
    Unavailable = 14,
    DataLoss = 15,
    Unauthenticated = 16,
}

impl ::protobuf::ProtobufEnum for Status_StatusCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Status_StatusCode> {
        match value {
            0 => ::std::option::Option::Some(Status_StatusCode::Ok),
            1 => ::std::option::Option::Some(Status_StatusCode::Cancelled),
            2 => ::std::option::Option::Some(Status_StatusCode::UnknownError),
            3 => ::std::option::Option::Some(Status_StatusCode::InvalidArgument),
            4 => ::std::option::Option::Some(Status_StatusCode::DeadlineExceeded),
            5 => ::std::option::Option::Some(Status_StatusCode::NotFound),
            6 => ::std::option::Option::Some(Status_StatusCode::AlreadyExists),
            7 => ::std::option::Option::Some(Status_StatusCode::PermissionDenied),
            8 => ::std::option::Option::Some(Status_StatusCode::ResourceExhausted),
            9 => ::std::option::Option::Some(Status_StatusCode::FailedPrecondition),
            10 => ::std::option::Option::Some(Status_StatusCode::Aborted),
            11 => ::std::option::Option::Some(Status_StatusCode::OutOfRange),
            12 => ::std::option::Option::Some(Status_StatusCode::Unimplemented),
            13 => ::std::option::Option::Some(Status_StatusCode::InternalError),
            14 => ::std::option::Option::Some(Status_StatusCode::Unavailable),
            15 => ::std::option::Option::Some(Status_StatusCode::DataLoss),
            16 => ::std::option::Option::Some(Status_StatusCode::Unauthenticated),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Status_StatusCode] = &[
            Status_StatusCode::Ok,
            Status_StatusCode::Cancelled,
            Status_StatusCode::UnknownError,
            Status_StatusCode::InvalidArgument,
            Status_StatusCode::DeadlineExceeded,
            Status_StatusCode::NotFound,
            Status_StatusCode::AlreadyExists,
            Status_StatusCode::PermissionDenied,
            Status_StatusCode::ResourceExhausted,
            Status_StatusCode::FailedPrecondition,
            Status_StatusCode::Aborted,
            Status_StatusCode::OutOfRange,
            Status_StatusCode::Unimplemented,
            Status_StatusCode::InternalError,
            Status_StatusCode::Unavailable,
            Status_StatusCode::DataLoss,
            Status_StatusCode::Unauthenticated,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Status_StatusCode>("Status.StatusCode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Status_StatusCode {
}

impl ::std::default::Default for Status_StatusCode {
    fn default() -> Self {
        Status_StatusCode::Ok
    }
}

impl ::protobuf::reflect::ProtobufValue for Status_StatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n(opentelemetry/proto/trace/v1/trace.proto\x12\x1copentelemetry.proto.t\
    race.v1\x1a*opentelemetry/proto/common/v1/common.proto\x1a.opentelemetry\
    /proto/resource/v1/resource.proto\"\xd5\x01\n\rResourceSpans\x12E\n\x08r\
    esource\x18\x01\x20\x01(\x0b2).opentelemetry.proto.resource.v1.ResourceR\
    \x08resource\x12}\n\x1dinstrumentation_library_spans\x18\x02\x20\x03(\
    \x0b29.opentelemetry.proto.trace.v1.InstrumentationLibrarySpansR\x1binst\
    rumentationLibrarySpans\"\xc7\x01\n\x1bInstrumentationLibrarySpans\x12n\
    \n\x17instrumentation_library\x18\x01\x20\x01(\x0b25.opentelemetry.proto\
    .common.v1.InstrumentationLibraryR\x16instrumentationLibrary\x128\n\x05s\
    pans\x18\x02\x20\x03(\x0b2\".opentelemetry.proto.trace.v1.SpanR\x05spans\
    \"\xe9\t\n\x04Span\x12\x19\n\x08trace_id\x18\x01\x20\x01(\x0cR\x07traceI\
    d\x12\x17\n\x07span_id\x18\x02\x20\x01(\x0cR\x06spanId\x12\x1f\n\x0btrac\
    e_state\x18\x03\x20\x01(\tR\ntraceState\x12$\n\x0eparent_span_id\x18\x04\
    \x20\x01(\x0cR\x0cparentSpanId\x12\x12\n\x04name\x18\x05\x20\x01(\tR\x04\
    name\x12?\n\x04kind\x18\x06\x20\x01(\x0e2+.opentelemetry.proto.trace.v1.\
    Span.SpanKindR\x04kind\x12/\n\x14start_time_unix_nano\x18\x07\x20\x01(\
    \x06R\x11startTimeUnixNano\x12+\n\x12end_time_unix_nano\x18\x08\x20\x01(\
    \x06R\x0fendTimeUnixNano\x12G\n\nattributes\x18\t\x20\x03(\x0b2'.opentel\
    emetry.proto.common.v1.KeyValueR\nattributes\x128\n\x18dropped_attribute\
    s_count\x18\n\x20\x01(\rR\x16droppedAttributesCount\x12@\n\x06events\x18\
    \x0b\x20\x03(\x0b2(.opentelemetry.proto.trace.v1.Span.EventR\x06events\
    \x120\n\x14dropped_events_count\x18\x0c\x20\x01(\rR\x12droppedEventsCoun\
    t\x12=\n\x05links\x18\r\x20\x03(\x0b2'.opentelemetry.proto.trace.v1.Span\
    .LinkR\x05links\x12.\n\x13dropped_links_count\x18\x0e\x20\x01(\rR\x11dro\
    ppedLinksCount\x12<\n\x06status\x18\x0f\x20\x01(\x0b2$.opentelemetry.pro\
    to.trace.v1.StatusR\x06status\x1a\xc4\x01\n\x05Event\x12$\n\x0etime_unix\
    _nano\x18\x01\x20\x01(\x06R\x0ctimeUnixNano\x12\x12\n\x04name\x18\x02\
    \x20\x01(\tR\x04name\x12G\n\nattributes\x18\x03\x20\x03(\x0b2'.opentelem\
    etry.proto.common.v1.KeyValueR\nattributes\x128\n\x18dropped_attributes_\
    count\x18\x04\x20\x01(\rR\x16droppedAttributesCount\x1a\xde\x01\n\x04Lin\
    k\x12\x19\n\x08trace_id\x18\x01\x20\x01(\x0cR\x07traceId\x12\x17\n\x07sp\
    an_id\x18\x02\x20\x01(\x0cR\x06spanId\x12\x1f\n\x0btrace_state\x18\x03\
    \x20\x01(\tR\ntraceState\x12G\n\nattributes\x18\x04\x20\x03(\x0b2'.opent\
    elemetry.proto.common.v1.KeyValueR\nattributes\x128\n\x18dropped_attribu\
    tes_count\x18\x05\x20\x01(\rR\x16droppedAttributesCount\"g\n\x08SpanKind\
    \x12\x19\n\x15SPAN_KIND_UNSPECIFIED\x10\0\x12\x0c\n\x08INTERNAL\x10\x01\
    \x12\n\n\x06SERVER\x10\x02\x12\n\n\x06CLIENT\x10\x03\x12\x0c\n\x08PRODUC\
    ER\x10\x04\x12\x0c\n\x08CONSUMER\x10\x05\"\xa7\x03\n\x06Status\x12C\n\
    \x04code\x18\x01\x20\x01(\x0e2/.opentelemetry.proto.trace.v1.Status.Stat\
    usCodeR\x04code\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\"\
    \xbd\x02\n\nStatusCode\x12\x06\n\x02Ok\x10\0\x12\r\n\tCancelled\x10\x01\
    \x12\x10\n\x0cUnknownError\x10\x02\x12\x13\n\x0fInvalidArgument\x10\x03\
    \x12\x14\n\x10DeadlineExceeded\x10\x04\x12\x0c\n\x08NotFound\x10\x05\x12\
    \x11\n\rAlreadyExists\x10\x06\x12\x14\n\x10PermissionDenied\x10\x07\x12\
    \x15\n\x11ResourceExhausted\x10\x08\x12\x16\n\x12FailedPrecondition\x10\
    \t\x12\x0b\n\x07Aborted\x10\n\x12\x0e\n\nOutOfRange\x10\x0b\x12\x11\n\rU\
    nimplemented\x10\x0c\x12\x11\n\rInternalError\x10\r\x12\x0f\n\x0bUnavail\
    able\x10\x0e\x12\x0c\n\x08DataLoss\x10\x0f\x12\x13\n\x0fUnauthenticated\
    \x10\x10Bn\n\x1fio.opentelemetry.proto.trace.v1B\nTraceProtoP\x01Z=githu\
    b.com/open-telemetry/opentelemetry-proto/gen/go/trace/v1b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
